From ed5db9693bc028ea1c98bfd084bff588eb182554 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 23 Aug 2021 19:57:38 -0700
Subject: [PATCH] resolv: fix memory leak when using libresolv

---
 src/subprojects/libslirp/slirp.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/subprojects/libslirp/src/slirp.c b/subprojects/libslirp/src/slirp.c
index 5d60cb5..05e2bb0 100644
--- a/subprojects/libslirp/src/slirp.c
+++ b/subprojects/libslirp/src/slirp.c
@@ -182,7 +182,7 @@ static int get_dns_addr_libresolv(int af, void *pdns_addr, void *cached_addr,
         }
     }
 
-    res_nclose(&state);
+    res_ndestroy(&state);
     if (!found)
         return -1;
     return 0;
-- 
2.28.0

From 29648be98733911329c6fcfa7abb70d01edebcc3 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 6 Sep 2021 11:17:50 -0700
Subject: [PATCH 1/5] Revert "target/i386: use mmu_translate for NPT walk"

This reverts commit 68746930ae591eca3d6dd490012b59e85194ede4.
---
 target/i386/tcg/sysemu/excp_helper.c | 243 +++++++++++++++++++++++----
 1 file changed, 207 insertions(+), 36 deletions(-)

diff --git a/target/i386/tcg/sysemu/excp_helper.c b/target/i386/tcg/sysemu/excp_helper.c
index b6d940e04e..082ddbb911 100644
--- a/target/i386/tcg/sysemu/excp_helper.c
+++ b/target/i386/tcg/sysemu/excp_helper.c
@@ -54,6 +54,210 @@ int get_pg_mode(CPUX86State *env)
     return pg_mode;
 }
 
+static hwaddr get_hphys(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
+                        int *prot)
+{
+    X86CPU *cpu = X86_CPU(cs);
+    CPUX86State *env = &cpu->env;
+    uint64_t rsvd_mask = PG_ADDRESS_MASK & ~MAKE_64BIT_MASK(0, cpu->phys_bits);
+    uint64_t ptep, pte;
+    uint64_t exit_info_1 = 0;
+    target_ulong pde_addr, pte_addr;
+    uint32_t page_offset;
+    int page_size;
+
+    if (likely(!(env->hflags2 & HF2_NPT_MASK))) {
+        return gphys;
+    }
+
+    if (!(env->nested_pg_mode & PG_MODE_NXE)) {
+        rsvd_mask |= PG_NX_MASK;
+    }
+
+    if (env->nested_pg_mode & PG_MODE_PAE) {
+        uint64_t pde, pdpe;
+        target_ulong pdpe_addr;
+
+#ifdef TARGET_X86_64
+        if (env->nested_pg_mode & PG_MODE_LMA) {
+            uint64_t pml5e;
+            uint64_t pml4e_addr, pml4e;
+
+            pml5e = env->nested_cr3;
+            ptep = PG_NX_MASK | PG_USER_MASK | PG_RW_MASK;
+
+            pml4e_addr = (pml5e & PG_ADDRESS_MASK) +
+                    (((gphys >> 39) & 0x1ff) << 3);
+            pml4e = x86_ldq_phys(cs, pml4e_addr);
+            if (!(pml4e & PG_PRESENT_MASK)) {
+                goto do_fault;
+            }
+            if (pml4e & (rsvd_mask | PG_PSE_MASK)) {
+                goto do_fault_rsvd;
+            }
+            if (!(pml4e & PG_ACCESSED_MASK)) {
+                pml4e |= PG_ACCESSED_MASK;
+                x86_stl_phys_notdirty(cs, pml4e_addr, pml4e);
+            }
+            ptep &= pml4e ^ PG_NX_MASK;
+            pdpe_addr = (pml4e & PG_ADDRESS_MASK) +
+                    (((gphys >> 30) & 0x1ff) << 3);
+            pdpe = x86_ldq_phys(cs, pdpe_addr);
+            if (!(pdpe & PG_PRESENT_MASK)) {
+                goto do_fault;
+            }
+            if (pdpe & rsvd_mask) {
+                goto do_fault_rsvd;
+            }
+            ptep &= pdpe ^ PG_NX_MASK;
+            if (!(pdpe & PG_ACCESSED_MASK)) {
+                pdpe |= PG_ACCESSED_MASK;
+                x86_stl_phys_notdirty(cs, pdpe_addr, pdpe);
+            }
+            if (pdpe & PG_PSE_MASK) {
+                /* 1 GB page */
+                page_size = 1024 * 1024 * 1024;
+                pte_addr = pdpe_addr;
+                pte = pdpe;
+                goto do_check_protect;
+            }
+        } else
+#endif
+        {
+            pdpe_addr = (env->nested_cr3 & ~0x1f) + ((gphys >> 27) & 0x18);
+            pdpe = x86_ldq_phys(cs, pdpe_addr);
+            if (!(pdpe & PG_PRESENT_MASK)) {
+                goto do_fault;
+            }
+            rsvd_mask |= PG_HI_USER_MASK;
+            if (pdpe & (rsvd_mask | PG_NX_MASK)) {
+                goto do_fault_rsvd;
+            }
+            ptep = PG_NX_MASK | PG_USER_MASK | PG_RW_MASK;
+        }
+
+        pde_addr = (pdpe & PG_ADDRESS_MASK) + (((gphys >> 21) & 0x1ff) << 3);
+        pde = x86_ldq_phys(cs, pde_addr);
+        if (!(pde & PG_PRESENT_MASK)) {
+            goto do_fault;
+        }
+        if (pde & rsvd_mask) {
+            goto do_fault_rsvd;
+        }
+        ptep &= pde ^ PG_NX_MASK;
+        if (pde & PG_PSE_MASK) {
+            /* 2 MB page */
+            page_size = 2048 * 1024;
+            pte_addr = pde_addr;
+            pte = pde;
+            goto do_check_protect;
+        }
+        /* 4 KB page */
+        if (!(pde & PG_ACCESSED_MASK)) {
+            pde |= PG_ACCESSED_MASK;
+            x86_stl_phys_notdirty(cs, pde_addr, pde);
+        }
+        pte_addr = (pde & PG_ADDRESS_MASK) + (((gphys >> 12) & 0x1ff) << 3);
+        pte = x86_ldq_phys(cs, pte_addr);
+        if (!(pte & PG_PRESENT_MASK)) {
+            goto do_fault;
+        }
+        if (pte & rsvd_mask) {
+            goto do_fault_rsvd;
+        }
+        /* combine pde and pte nx, user and rw protections */
+        ptep &= pte ^ PG_NX_MASK;
+        page_size = 4096;
+    } else {
+        uint32_t pde;
+
+        /* page directory entry */
+        pde_addr = (env->nested_cr3 & ~0xfff) + ((gphys >> 20) & 0xffc);
+        pde = x86_ldl_phys(cs, pde_addr);
+        if (!(pde & PG_PRESENT_MASK)) {
+            goto do_fault;
+        }
+        ptep = pde | PG_NX_MASK;
+
+        /* if host cr4 PSE bit is set, then we use a 4MB page */
+        if ((pde & PG_PSE_MASK) && (env->nested_pg_mode & PG_MODE_PSE)) {
+            page_size = 4096 * 1024;
+            pte_addr = pde_addr;
+
+            /* Bits 20-13 provide bits 39-32 of the address, bit 21 is reserved.
+             * Leave bits 20-13 in place for setting accessed/dirty bits below.
+             */
+            pte = pde | ((pde & 0x1fe000LL) << (32 - 13));
+            rsvd_mask = 0x200000;
+            goto do_check_protect_pse36;
+        }
+
+        if (!(pde & PG_ACCESSED_MASK)) {
+            pde |= PG_ACCESSED_MASK;
+            x86_stl_phys_notdirty(cs, pde_addr, pde);
+        }
+
+        /* page directory entry */
+        pte_addr = (pde & ~0xfff) + ((gphys >> 10) & 0xffc);
+        pte = x86_ldl_phys(cs, pte_addr);
+        if (!(pte & PG_PRESENT_MASK)) {
+            goto do_fault;
+        }
+        /* combine pde and pte user and rw protections */
+        ptep &= pte | PG_NX_MASK;
+        page_size = 4096;
+        rsvd_mask = 0;
+    }
+
+ do_check_protect:
+    rsvd_mask |= (page_size - 1) & PG_ADDRESS_MASK & ~PG_PSE_PAT_MASK;
+ do_check_protect_pse36:
+    if (pte & rsvd_mask) {
+        goto do_fault_rsvd;
+    }
+    ptep ^= PG_NX_MASK;
+
+    if (!(ptep & PG_USER_MASK)) {
+        goto do_fault_protect;
+    }
+    if (ptep & PG_NX_MASK) {
+        if (access_type == MMU_INST_FETCH) {
+            goto do_fault_protect;
+        }
+        *prot &= ~PAGE_EXEC;
+    }
+    if (!(ptep & PG_RW_MASK)) {
+        if (access_type == MMU_DATA_STORE) {
+            goto do_fault_protect;
+        }
+        *prot &= ~PAGE_WRITE;
+    }
+
+    pte &= PG_ADDRESS_MASK & ~(page_size - 1);
+    page_offset = gphys & (page_size - 1);
+    return pte + page_offset;
+
+ do_fault_rsvd:
+    exit_info_1 |= PG_ERROR_RSVD_MASK;
+ do_fault_protect:
+    exit_info_1 |= PG_ERROR_P_MASK;
+ do_fault:
+    x86_stq_phys(cs, env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),
+                 gphys);
+    exit_info_1 |= PG_ERROR_U_MASK;
+    if (access_type == MMU_DATA_STORE) {
+        exit_info_1 |= PG_ERROR_W_MASK;
+    } else if (access_type == MMU_INST_FETCH) {
+        exit_info_1 |= PG_ERROR_I_D_MASK;
+    }
+    if (prot) {
+        exit_info_1 |= SVM_NPTEXIT_GPA;
+    } else { /* page table access */
+        exit_info_1 |= SVM_NPTEXIT_GPT;
+    }
+    cpu_vmexit(env, SVM_EXIT_NPF, exit_info_1, env->retaddr);
+}
+
 #define PG_ERROR_OK (-1)
 
 typedef hwaddr (*MMUTranslateFunc)(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
@@ -62,9 +266,9 @@ typedef hwaddr (*MMUTranslateFunc)(CPUState *cs, hwaddr gphys, MMUAccessType acc
 #define GET_HPHYS(cs, gpa, access_type, prot)  \
 	(get_hphys_func ? get_hphys_func(cs, gpa, access_type, prot) : gpa)
 
-static int mmu_translate(CPUState *cs, hwaddr addr, MMUTranslateFunc get_hphys_func,
+static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_func,
                          uint64_t cr3, int is_write1, int mmu_idx, int pg_mode,
-                         hwaddr *xlat, int *page_size, int *prot)
+                         vaddr *xlat, int *page_size, int *prot)
 {
     X86CPU *cpu = X86_CPU(cs);
     CPUX86State *env = &cpu->env;
@@ -358,39 +562,6 @@ do_check_protect_pse36:
     return error_code;
 }
 
-static hwaddr get_hphys(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
-                        int *prot)
-{
-    CPUX86State *env = &X86_CPU(cs)->env;
-    uint64_t exit_info_1;
-    int page_size;
-    int next_prot;
-    hwaddr hphys;
-
-    if (likely(!(env->hflags2 & HF2_NPT_MASK))) {
-        return gphys;
-    }
-
-    exit_info_1 = mmu_translate(cs, gphys, NULL, env->nested_cr3,
-                               access_type, MMU_USER_IDX, env->nested_pg_mode,
-                               &hphys, &page_size, &next_prot);
-    if (exit_info_1 == PG_ERROR_OK) {
-        if (prot) {
-            *prot &= next_prot;
-        }
-        return hphys;
-    }
-
-    x86_stq_phys(cs, env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),
-                 gphys);
-    if (prot) {
-        exit_info_1 |= SVM_NPTEXIT_GPA;
-    } else { /* page table access */
-        exit_info_1 |= SVM_NPTEXIT_GPT;
-    }
-    cpu_vmexit(env, SVM_EXIT_NPF, exit_info_1, env->retaddr);
-}
-
 /* return value:
  * -1 = cannot handle fault
  * 0  = nothing more to do
@@ -404,7 +575,7 @@ static int handle_mmu_fault(CPUState *cs, vaddr addr, int size,
     int error_code = PG_ERROR_OK;
     int pg_mode, prot, page_size;
     hwaddr paddr;
-    hwaddr vaddr;
+    target_ulong vaddr;
 
 #if defined(DEBUG_MMU)
     printf("MMU fault: addr=%" VADDR_PRIx " w=%d mmu=%d eip=" TARGET_FMT_lx "\n",
-- 
2.28.0

From 1d5d0e328405d5388316c0e30db2e24885b0f546 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 6 Sep 2021 11:18:26 -0700
Subject: [PATCH 2/5] Revert "target/i386: allow customizing the next phase of
 the translation"

This reverts commit 33ce155c6779baf3a01b22782632bda0cec352fb.
---
 target/i386/tcg/sysemu/excp_helper.c | 30 +++++++++++-----------------
 1 file changed, 12 insertions(+), 18 deletions(-)

diff --git a/target/i386/tcg/sysemu/excp_helper.c b/target/i386/tcg/sysemu/excp_helper.c
index 082ddbb911..2b7baa0193 100644
--- a/target/i386/tcg/sysemu/excp_helper.c
+++ b/target/i386/tcg/sysemu/excp_helper.c
@@ -260,13 +260,7 @@ static hwaddr get_hphys(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
 
 #define PG_ERROR_OK (-1)
 
-typedef hwaddr (*MMUTranslateFunc)(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
-				int *prot);
-
-#define GET_HPHYS(cs, gpa, access_type, prot)  \
-	(get_hphys_func ? get_hphys_func(cs, gpa, access_type, prot) : gpa)
-
-static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_func,
+static int mmu_translate(CPUState *cs, vaddr addr,
                          uint64_t cr3, int is_write1, int mmu_idx, int pg_mode,
                          vaddr *xlat, int *page_size, int *prot)
 {
@@ -302,7 +296,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
 
             /* test virtual address sign extension */
             sext = la57 ? (int64_t)addr >> 56 : (int64_t)addr >> 47;
-            if (get_hphys_func && sext != 0 && sext != -1) {
+            if (sext != 0 && sext != -1) {
                 env->error_code = 0;
                 cs->exception_index = EXCP0D_GPF;
                 return 1;
@@ -311,7 +305,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
             if (la57) {
                 pml5e_addr = ((cr3 & ~0xfff) +
                         (((addr >> 48) & 0x1ff) << 3)) & a20_mask;
-                pml5e_addr = GET_HPHYS(cs, pml5e_addr, MMU_DATA_STORE, NULL);
+                pml5e_addr = get_hphys(cs, pml5e_addr, MMU_DATA_STORE, NULL);
                 pml5e = x86_ldq_phys(cs, pml5e_addr);
                 if (!(pml5e & PG_PRESENT_MASK)) {
                     goto do_fault;
@@ -331,7 +325,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
 
             pml4e_addr = ((pml5e & PG_ADDRESS_MASK) +
                     (((addr >> 39) & 0x1ff) << 3)) & a20_mask;
-            pml4e_addr = GET_HPHYS(cs, pml4e_addr, MMU_DATA_STORE, NULL);
+            pml4e_addr = get_hphys(cs, pml4e_addr, MMU_DATA_STORE, false);
             pml4e = x86_ldq_phys(cs, pml4e_addr);
             if (!(pml4e & PG_PRESENT_MASK)) {
                 goto do_fault;
@@ -346,7 +340,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
             ptep &= pml4e ^ PG_NX_MASK;
             pdpe_addr = ((pml4e & PG_ADDRESS_MASK) + (((addr >> 30) & 0x1ff) << 3)) &
                 a20_mask;
-            pdpe_addr = GET_HPHYS(cs, pdpe_addr, MMU_DATA_STORE, NULL);
+            pdpe_addr = get_hphys(cs, pdpe_addr, MMU_DATA_STORE, NULL);
             pdpe = x86_ldq_phys(cs, pdpe_addr);
             if (!(pdpe & PG_PRESENT_MASK)) {
                 goto do_fault;
@@ -372,7 +366,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
             /* XXX: load them when cr3 is loaded ? */
             pdpe_addr = ((cr3 & ~0x1f) + ((addr >> 27) & 0x18)) &
                 a20_mask;
-            pdpe_addr = GET_HPHYS(cs, pdpe_addr, MMU_DATA_STORE, NULL);
+            pdpe_addr = get_hphys(cs, pdpe_addr, MMU_DATA_STORE, false);
             pdpe = x86_ldq_phys(cs, pdpe_addr);
             if (!(pdpe & PG_PRESENT_MASK)) {
                 goto do_fault;
@@ -386,7 +380,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
 
         pde_addr = ((pdpe & PG_ADDRESS_MASK) + (((addr >> 21) & 0x1ff) << 3)) &
             a20_mask;
-        pde_addr = GET_HPHYS(cs, pde_addr, MMU_DATA_STORE, NULL);
+        pde_addr = get_hphys(cs, pde_addr, MMU_DATA_STORE, NULL);
         pde = x86_ldq_phys(cs, pde_addr);
         if (!(pde & PG_PRESENT_MASK)) {
             goto do_fault;
@@ -409,7 +403,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
         }
         pte_addr = ((pde & PG_ADDRESS_MASK) + (((addr >> 12) & 0x1ff) << 3)) &
             a20_mask;
-        pte_addr = GET_HPHYS(cs, pte_addr, MMU_DATA_STORE, NULL);
+        pte_addr = get_hphys(cs, pte_addr, MMU_DATA_STORE, NULL);
         pte = x86_ldq_phys(cs, pte_addr);
         if (!(pte & PG_PRESENT_MASK)) {
             goto do_fault;
@@ -426,7 +420,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
         /* page directory entry */
         pde_addr = ((cr3 & ~0xfff) + ((addr >> 20) & 0xffc)) &
             a20_mask;
-        pde_addr = GET_HPHYS(cs, pde_addr, MMU_DATA_STORE, NULL);
+        pde_addr = get_hphys(cs, pde_addr, MMU_DATA_STORE, NULL);
         pde = x86_ldl_phys(cs, pde_addr);
         if (!(pde & PG_PRESENT_MASK)) {
             goto do_fault;
@@ -454,7 +448,7 @@ static int mmu_translate(CPUState *cs, vaddr addr, MMUTranslateFunc get_hphys_fu
         /* page directory entry */
         pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) &
             a20_mask;
-        pte_addr = GET_HPHYS(cs, pte_addr, MMU_DATA_STORE, NULL);
+        pte_addr = get_hphys(cs, pte_addr, MMU_DATA_STORE, NULL);
         pte = x86_ldl_phys(cs, pte_addr);
         if (!(pte & PG_PRESENT_MASK)) {
             goto do_fault;
@@ -544,7 +538,7 @@ do_check_protect_pse36:
     /* align to page_size */
     pte &= PG_ADDRESS_MASK & ~(*page_size - 1);
     page_offset = addr & (*page_size - 1);
-    *xlat = GET_HPHYS(cs, pte + page_offset, is_write1, prot);
+    *xlat = get_hphys(cs, pte + page_offset, is_write1, prot);
     return PG_ERROR_OK;
 
  do_fault_rsvd:
@@ -594,7 +588,7 @@ static int handle_mmu_fault(CPUState *cs, vaddr addr, int size,
         page_size = 4096;
     } else {
         pg_mode = get_pg_mode(env);
-        error_code = mmu_translate(cs, addr, get_hphys, env->cr[3], is_write1,
+        error_code = mmu_translate(cs, addr, env->cr[3], is_write1,
                                    mmu_idx, pg_mode,
                                    &paddr, &page_size, &prot);
     }
-- 
2.28.0

From 3dd6929e4073fd6d98c1360865bc9b21ccba4f16 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 6 Sep 2021 11:18:49 -0700
Subject: [PATCH 3/5] Revert "target/i386: extend pg_mode to more CR0 and CR4
 bits"

This reverts commit 31dd35eb2d4484b70e4462a9e4a370695cc8ce8d.
---
 target/i386/cpu.h                    |  8 -----
 target/i386/tcg/sysemu/excp_helper.c | 45 ++++++++++------------------
 target/i386/tcg/sysemu/svm_helper.c  |  2 +-
 3 files changed, 16 insertions(+), 39 deletions(-)

diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 6c50d3ab4f..808295a90f 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -320,14 +320,6 @@ typedef enum X86Seg {
 #define PG_MODE_LMA      (1 << 1)
 #define PG_MODE_NXE      (1 << 2)
 #define PG_MODE_PSE      (1 << 3)
-#define PG_MODE_LA57     (1 << 4)
-#define PG_MODE_SVM_MASK MAKE_64BIT_MASK(0, 15)
-
-/* Bits of CR4 that do not affect the NPT page format.  */
-#define PG_MODE_WP       (1 << 16)
-#define PG_MODE_PKE      (1 << 17)
-#define PG_MODE_PKS      (1 << 18)
-#define PG_MODE_SMEP     (1 << 19)
 
 #define MCG_CTL_P       (1ULL<<8)   /* MCG_CAP register available */
 #define MCG_SER_P       (1ULL<<24) /* MCA recovery/new status bits */
diff --git a/target/i386/tcg/sysemu/excp_helper.c b/target/i386/tcg/sysemu/excp_helper.c
index 2b7baa0193..4cf04f4e96 100644
--- a/target/i386/tcg/sysemu/excp_helper.c
+++ b/target/i386/tcg/sysemu/excp_helper.c
@@ -24,27 +24,12 @@
 int get_pg_mode(CPUX86State *env)
 {
     int pg_mode = 0;
-    if (env->cr[0] & CR0_WP_MASK) {
-        pg_mode |= PG_MODE_WP;
-    }
     if (env->cr[4] & CR4_PAE_MASK) {
         pg_mode |= PG_MODE_PAE;
     }
     if (env->cr[4] & CR4_PSE_MASK) {
         pg_mode |= PG_MODE_PSE;
     }
-    if (env->cr[4] & CR4_PKE_MASK) {
-        pg_mode |= PG_MODE_PKE;
-    }
-    if (env->cr[4] & CR4_PKS_MASK) {
-        pg_mode |= PG_MODE_PKS;
-    }
-    if (env->cr[4] & CR4_SMEP_MASK) {
-        pg_mode |= PG_MODE_SMEP;
-    }
-    if (env->cr[4] & CR4_LA57_MASK) {
-        pg_mode |= PG_MODE_LA57;
-    }
     if (env->hflags & HF_LMA_MASK) {
         pg_mode |= PG_MODE_LMA;
     }
@@ -261,7 +246,7 @@ static hwaddr get_hphys(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
 #define PG_ERROR_OK (-1)
 
 static int mmu_translate(CPUState *cs, vaddr addr,
-                         uint64_t cr3, int is_write1, int mmu_idx, int pg_mode,
+                         uint64_t cr3, int is_write1, int mmu_idx,
                          vaddr *xlat, int *page_size, int *prot)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -279,17 +264,17 @@ static int mmu_translate(CPUState *cs, vaddr addr,
     is_write = is_write1 & 1;
     a20_mask = x86_get_a20_mask(env);
 
-    if (!(pg_mode & PG_MODE_NXE)) {
+    if (!(env->efer & MSR_EFER_NXE)) {
         rsvd_mask |= PG_NX_MASK;
     }
 
-    if (pg_mode & PG_MODE_PAE) {
+    if (env->cr[4] & CR4_PAE_MASK) {
         uint64_t pde, pdpe;
         target_ulong pdpe_addr;
 
 #ifdef TARGET_X86_64
         if (env->hflags & HF_LMA_MASK) {
-            bool la57 = pg_mode & PG_MODE_LA57;
+            bool la57 = env->cr[4] & CR4_LA57_MASK;
             uint64_t pml5e_addr, pml5e;
             uint64_t pml4e_addr, pml4e;
             int32_t sext;
@@ -428,7 +413,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
         ptep = pde | PG_NX_MASK;
 
         /* if PSE bit is set, then we use a 4MB page */
-        if ((pde & PG_PSE_MASK) && (pg_mode & PG_MODE_PSE)) {
+        if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
             *page_size = 4096 * 1024;
             pte_addr = pde_addr;
 
@@ -475,22 +460,22 @@ do_check_protect_pse36:
     *prot = 0;
     if (mmu_idx != MMU_KSMAP_IDX || !(ptep & PG_USER_MASK)) {
         *prot |= PAGE_READ;
-        if ((ptep & PG_RW_MASK) || !(is_user || (pg_mode & PG_MODE_WP))) {
+        if ((ptep & PG_RW_MASK) || (!is_user && !(env->cr[0] & CR0_WP_MASK))) {
             *prot |= PAGE_WRITE;
         }
     }
     if (!(ptep & PG_NX_MASK) &&
         (mmu_idx == MMU_USER_IDX ||
-         !((pg_mode & PG_MODE_SMEP) && (ptep & PG_USER_MASK)))) {
+         !((env->cr[4] & CR4_SMEP_MASK) && (ptep & PG_USER_MASK)))) {
         *prot |= PAGE_EXEC;
     }
 
     if (!(env->hflags & HF_LMA_MASK)) {
         pkr = 0;
     } else if (ptep & PG_USER_MASK) {
-        pkr = pg_mode & PG_MODE_PKE ? env->pkru : 0;
+        pkr = env->cr[4] & CR4_PKE_MASK ? env->pkru : 0;
     } else {
-        pkr = pg_mode & PG_MODE_PKS ? env->pkrs : 0;
+        pkr = env->cr[4] & CR4_PKS_MASK ? env->pkrs : 0;
     }
     if (pkr) {
         uint32_t pk = (pte & PG_PKRU_MASK) >> PG_PKRU_BIT;
@@ -500,7 +485,7 @@ do_check_protect_pse36:
 
         if (pkr_ad) {
             pkr_prot &= ~(PAGE_READ | PAGE_WRITE);
-        } else if (pkr_wd && (is_user || (pg_mode & PG_MODE_WP))) {
+        } else if (pkr_wd && (is_user || env->cr[0] & CR0_WP_MASK)) {
             pkr_prot &= ~PAGE_WRITE;
         }
 
@@ -550,8 +535,9 @@ do_check_protect_pse36:
     if (is_user)
         error_code |= PG_ERROR_U_MASK;
     if (is_write1 == 2 &&
-        (((pg_mode & PG_MODE_NXE) && (pg_mode & PG_MODE_PAE)) ||
-         (pg_mode & PG_MODE_SMEP)))
+        (((env->efer & MSR_EFER_NXE) &&
+	  (env->cr[4] & CR4_PAE_MASK)) ||
+         (env->cr[4] & CR4_SMEP_MASK)))
         error_code |= PG_ERROR_I_D_MASK;
     return error_code;
 }
@@ -567,7 +553,7 @@ static int handle_mmu_fault(CPUState *cs, vaddr addr, int size,
     X86CPU *cpu = X86_CPU(cs);
     CPUX86State *env = &cpu->env;
     int error_code = PG_ERROR_OK;
-    int pg_mode, prot, page_size;
+    int prot, page_size;
     hwaddr paddr;
     target_ulong vaddr;
 
@@ -587,9 +573,8 @@ static int handle_mmu_fault(CPUState *cs, vaddr addr, int size,
         prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
         page_size = 4096;
     } else {
-        pg_mode = get_pg_mode(env);
         error_code = mmu_translate(cs, addr, env->cr[3], is_write1,
-                                   mmu_idx, pg_mode,
+                                   mmu_idx,
                                    &paddr, &page_size, &prot);
     }
 
diff --git a/target/i386/tcg/sysemu/svm_helper.c b/target/i386/tcg/sysemu/svm_helper.c
index 0d549b3d6c..2a369749e2 100644
--- a/target/i386/tcg/sysemu/svm_helper.c
+++ b/target/i386/tcg/sysemu/svm_helper.c
@@ -236,7 +236,7 @@ void helper_vmrun(CPUX86State *env, int aflag, int next_eip_addend)
                                                         control.nested_cr3));
         env->hflags2 |= HF2_NPT_MASK;
 
-        env->nested_pg_mode = get_pg_mode(env) & PG_MODE_SVM_MASK;
+        env->nested_pg_mode = get_pg_mode(env);
     }
 
     /* enable intercepts */
-- 
2.28.0

From 8a9f1a3bd6856ae962ec5abd2f04eadf65ba4cac Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 6 Sep 2021 11:18:51 -0700
Subject: [PATCH 4/5] Revert "target/i386: pass cr3 to mmu_translate"

This reverts commit cd906d315d629da010e0ac6f84949c04d2ab7a08.
---
 target/i386/tcg/sysemu/excp_helper.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/target/i386/tcg/sysemu/excp_helper.c b/target/i386/tcg/sysemu/excp_helper.c
index 4cf04f4e96..f1103db64f 100644
--- a/target/i386/tcg/sysemu/excp_helper.c
+++ b/target/i386/tcg/sysemu/excp_helper.c
@@ -246,7 +246,7 @@ static hwaddr get_hphys(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
 #define PG_ERROR_OK (-1)
 
 static int mmu_translate(CPUState *cs, vaddr addr,
-                         uint64_t cr3, int is_write1, int mmu_idx,
+                         int is_write1, int mmu_idx,
                          vaddr *xlat, int *page_size, int *prot)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -288,7 +288,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
             }
 
             if (la57) {
-                pml5e_addr = ((cr3 & ~0xfff) +
+                pml5e_addr = ((env->cr[3] & ~0xfff) +
                         (((addr >> 48) & 0x1ff) << 3)) & a20_mask;
                 pml5e_addr = get_hphys(cs, pml5e_addr, MMU_DATA_STORE, NULL);
                 pml5e = x86_ldq_phys(cs, pml5e_addr);
@@ -304,7 +304,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
                 }
                 ptep = pml5e ^ PG_NX_MASK;
             } else {
-                pml5e = cr3;
+                pml5e = env->cr[3];
                 ptep = PG_NX_MASK | PG_USER_MASK | PG_RW_MASK;
             }
 
@@ -349,7 +349,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
 #endif
         {
             /* XXX: load them when cr3 is loaded ? */
-            pdpe_addr = ((cr3 & ~0x1f) + ((addr >> 27) & 0x18)) &
+            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &
                 a20_mask;
             pdpe_addr = get_hphys(cs, pdpe_addr, MMU_DATA_STORE, false);
             pdpe = x86_ldq_phys(cs, pdpe_addr);
@@ -403,7 +403,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
         uint32_t pde;
 
         /* page directory entry */
-        pde_addr = ((cr3 & ~0xfff) + ((addr >> 20) & 0xffc)) &
+        pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) &
             a20_mask;
         pde_addr = get_hphys(cs, pde_addr, MMU_DATA_STORE, NULL);
         pde = x86_ldl_phys(cs, pde_addr);
@@ -573,7 +573,7 @@ static int handle_mmu_fault(CPUState *cs, vaddr addr, int size,
         prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
         page_size = 4096;
     } else {
-        error_code = mmu_translate(cs, addr, env->cr[3], is_write1,
+        error_code = mmu_translate(cs, addr, is_write1,
                                    mmu_idx,
                                    &paddr, &page_size, &prot);
     }
-- 
2.28.0

From b7d00686fc1d84daf7082ae3e2bc3fddeec29a3c Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 6 Sep 2021 11:19:08 -0700
Subject: [PATCH 5/5] Revert "target/i386: extract mmu_translate"

This reverts commit 661ff4879eee77953836ba9843c74b202844a492.
---
 target/i386/tcg/sysemu/excp_helper.c | 151 ++++++++++++---------------
 1 file changed, 65 insertions(+), 86 deletions(-)

diff --git a/target/i386/tcg/sysemu/excp_helper.c b/target/i386/tcg/sysemu/excp_helper.c
index f1103db64f..e616ac6f13 100644
--- a/target/i386/tcg/sysemu/excp_helper.c
+++ b/target/i386/tcg/sysemu/excp_helper.c
@@ -243,11 +243,13 @@ static hwaddr get_hphys(CPUState *cs, hwaddr gphys, MMUAccessType access_type,
     cpu_vmexit(env, SVM_EXIT_NPF, exit_info_1, env->retaddr);
 }
 
-#define PG_ERROR_OK (-1)
-
-static int mmu_translate(CPUState *cs, vaddr addr,
-                         int is_write1, int mmu_idx,
-                         vaddr *xlat, int *page_size, int *prot)
+/* return value:
+ * -1 = cannot handle fault
+ * 0  = nothing more to do
+ * 1  = generate PF fault
+ */
+static int handle_mmu_fault(CPUState *cs, vaddr addr, int size,
+                            int is_write1, int mmu_idx)
 {
     X86CPU *cpu = X86_CPU(cs);
     CPUX86State *env = &cpu->env;
@@ -255,14 +257,33 @@ static int mmu_translate(CPUState *cs, vaddr addr,
     int32_t a20_mask;
     target_ulong pde_addr, pte_addr;
     int error_code = 0;
-    int is_dirty, is_write, is_user;
+    int is_dirty, prot, page_size, is_write, is_user;
+    hwaddr paddr;
     uint64_t rsvd_mask = PG_ADDRESS_MASK & ~MAKE_64BIT_MASK(0, cpu->phys_bits);
     uint32_t page_offset;
+    target_ulong vaddr;
     uint32_t pkr;
 
-    is_user = (mmu_idx == MMU_USER_IDX);
+    is_user = mmu_idx == MMU_USER_IDX;
+#if defined(DEBUG_MMU)
+    printf("MMU fault: addr=%" VADDR_PRIx " w=%d u=%d eip=" TARGET_FMT_lx "\n",
+           addr, is_write1, is_user, env->eip);
+#endif
     is_write = is_write1 & 1;
+
     a20_mask = x86_get_a20_mask(env);
+    if (!(env->cr[0] & CR0_PG_MASK)) {
+        pte = addr;
+#ifdef TARGET_X86_64
+        if (!(env->hflags & HF_LMA_MASK)) {
+            /* Without long mode we can only address 32bits in real mode */
+            pte = (uint32_t)pte;
+        }
+#endif
+        prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
+        page_size = 4096;
+        goto do_mapping;
+    }
 
     if (!(env->efer & MSR_EFER_NXE)) {
         rsvd_mask |= PG_NX_MASK;
@@ -340,7 +361,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
             }
             if (pdpe & PG_PSE_MASK) {
                 /* 1 GB page */
-                *page_size = 1024 * 1024 * 1024;
+                page_size = 1024 * 1024 * 1024;
                 pte_addr = pdpe_addr;
                 pte = pdpe;
                 goto do_check_protect;
@@ -376,7 +397,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
         ptep &= pde ^ PG_NX_MASK;
         if (pde & PG_PSE_MASK) {
             /* 2 MB page */
-            *page_size = 2048 * 1024;
+            page_size = 2048 * 1024;
             pte_addr = pde_addr;
             pte = pde;
             goto do_check_protect;
@@ -398,7 +419,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
         }
         /* combine pde and pte nx, user and rw protections */
         ptep &= pte ^ PG_NX_MASK;
-        *page_size = 4096;
+        page_size = 4096;
     } else {
         uint32_t pde;
 
@@ -414,7 +435,7 @@ static int mmu_translate(CPUState *cs, vaddr addr,
 
         /* if PSE bit is set, then we use a 4MB page */
         if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
-            *page_size = 4096 * 1024;
+            page_size = 4096 * 1024;
             pte_addr = pde_addr;
 
             /* Bits 20-13 provide bits 39-32 of the address, bit 21 is reserved.
@@ -440,12 +461,12 @@ static int mmu_translate(CPUState *cs, vaddr addr,
         }
         /* combine pde and pte user and rw protections */
         ptep &= pte | PG_NX_MASK;
-        *page_size = 4096;
+        page_size = 4096;
         rsvd_mask = 0;
     }
 
 do_check_protect:
-    rsvd_mask |= (*page_size - 1) & PG_ADDRESS_MASK & ~PG_PSE_PAT_MASK;
+    rsvd_mask |= (page_size - 1) & PG_ADDRESS_MASK & ~PG_PSE_PAT_MASK;
 do_check_protect_pse36:
     if (pte & rsvd_mask) {
         goto do_fault_rsvd;
@@ -457,17 +478,17 @@ do_check_protect_pse36:
         goto do_fault_protect;
     }
 
-    *prot = 0;
+    prot = 0;
     if (mmu_idx != MMU_KSMAP_IDX || !(ptep & PG_USER_MASK)) {
-        *prot |= PAGE_READ;
+        prot |= PAGE_READ;
         if ((ptep & PG_RW_MASK) || (!is_user && !(env->cr[0] & CR0_WP_MASK))) {
-            *prot |= PAGE_WRITE;
+            prot |= PAGE_WRITE;
         }
     }
     if (!(ptep & PG_NX_MASK) &&
         (mmu_idx == MMU_USER_IDX ||
          !((env->cr[4] & CR4_SMEP_MASK) && (ptep & PG_USER_MASK)))) {
-        *prot |= PAGE_EXEC;
+        prot |= PAGE_EXEC;
     }
 
     if (!(env->hflags & HF_LMA_MASK)) {
@@ -489,7 +510,7 @@ do_check_protect_pse36:
             pkr_prot &= ~PAGE_WRITE;
         }
 
-        *prot &= pkr_prot;
+        prot &= pkr_prot;
         if ((pkr_prot & (1 << is_write1)) == 0) {
             assert(is_write1 != 2);
             error_code |= PG_ERROR_PK_MASK;
@@ -497,7 +518,7 @@ do_check_protect_pse36:
         }
     }
 
-    if ((*prot & (1 << is_write1)) == 0) {
+    if ((prot & (1 << is_write1)) == 0) {
         goto do_fault_protect;
     }
 
@@ -515,17 +536,26 @@ do_check_protect_pse36:
         /* only set write access if already dirty... otherwise wait
            for dirty access */
         assert(!is_write);
-        *prot &= ~PAGE_WRITE;
+        prot &= ~PAGE_WRITE;
     }
 
+ do_mapping:
     pte = pte & a20_mask;
 
     /* align to page_size */
-    pte &= PG_ADDRESS_MASK & ~(*page_size - 1);
-    page_offset = addr & (*page_size - 1);
-    *xlat = get_hphys(cs, pte + page_offset, is_write1, prot);
-    return PG_ERROR_OK;
-
+    pte &= PG_ADDRESS_MASK & ~(page_size - 1);
+    page_offset = addr & (page_size - 1);
+    paddr = get_hphys(cs, pte + page_offset, is_write1, &prot);
+
+    /* Even if 4MB pages, we map only one 4KB page in the cache to
+       avoid filling it too fast */
+    vaddr = addr & TARGET_PAGE_MASK;
+    paddr &= TARGET_PAGE_MASK;
+
+    assert(prot & (1 << is_write1));
+    tlb_set_page_with_attrs(cs, vaddr, paddr, cpu_get_mem_attrs(env),
+                            prot, mmu_idx, page_size);
+    return 0;
  do_fault_rsvd:
     error_code |= PG_ERROR_RSVD_MASK;
  do_fault_protect:
@@ -536,71 +566,20 @@ do_check_protect_pse36:
         error_code |= PG_ERROR_U_MASK;
     if (is_write1 == 2 &&
         (((env->efer & MSR_EFER_NXE) &&
-	  (env->cr[4] & CR4_PAE_MASK)) ||
+          (env->cr[4] & CR4_PAE_MASK)) ||
          (env->cr[4] & CR4_SMEP_MASK)))
         error_code |= PG_ERROR_I_D_MASK;
-    return error_code;
-}
-
-/* return value:
- * -1 = cannot handle fault
- * 0  = nothing more to do
- * 1  = generate PF fault
- */
-static int handle_mmu_fault(CPUState *cs, vaddr addr, int size,
-                            int is_write1, int mmu_idx)
-{
-    X86CPU *cpu = X86_CPU(cs);
-    CPUX86State *env = &cpu->env;
-    int error_code = PG_ERROR_OK;
-    int prot, page_size;
-    hwaddr paddr;
-    target_ulong vaddr;
-
-#if defined(DEBUG_MMU)
-    printf("MMU fault: addr=%" VADDR_PRIx " w=%d mmu=%d eip=" TARGET_FMT_lx "\n",
-           addr, is_write1, mmu_idx, env->eip);
-#endif
-
-    if (!(env->cr[0] & CR0_PG_MASK)) {
-        paddr = addr;
-#ifdef TARGET_X86_64
-        if (!(env->hflags & HF_LMA_MASK)) {
-            /* Without long mode we can only address 32bits in real mode */
-            paddr = (uint32_t)paddr;
-        }
-#endif
-        prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
-        page_size = 4096;
+    if (env->intercept_exceptions & (1 << EXCP0E_PAGE)) {
+        /* cr2 is not modified in case of exceptions */
+        x86_stq_phys(cs,
+                 env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),
+                 addr);
     } else {
-        error_code = mmu_translate(cs, addr, is_write1,
-                                   mmu_idx,
-                                   &paddr, &page_size, &prot);
-    }
-
-    if (error_code == PG_ERROR_OK) {
-        /* Even if 4MB pages, we map only one 4KB page in the cache to
-           avoid filling it too fast */
-        vaddr = addr & TARGET_PAGE_MASK;
-        paddr &= TARGET_PAGE_MASK;
-
-        assert(prot & (1 << is_write1));
-        tlb_set_page_with_attrs(cs, vaddr, paddr, cpu_get_mem_attrs(env),
-                                prot, mmu_idx, page_size);
-        return 0;
-    } else {
-        if (env->intercept_exceptions & (1 << EXCP0E_PAGE)) {
-            /* cr2 is not modified in case of exceptions */
-            x86_stq_phys(cs,
-                     env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2),
-                     addr);
-        } else {
-            env->cr[2] = addr;
-        }
-        env->error_code = error_code;
-        cs->exception_index = EXCP0E_PAGE;
-        return 1;
+        env->cr[2] = addr;
     }
+    env->error_code = error_code;
+    cs->exception_index = EXCP0E_PAGE;
+    return 1;
 }
 
 bool x86_cpu_tlb_fill(CPUState *cs, vaddr addr, int size,
-- 
2.28.0

From 2b73a7937ddc83f4ec0bdbe16abf8453c07fb990 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Tue, 7 Sep 2021 01:36:59 -0700
Subject: [PATCH] virtio-ramfb: break out GL supported device

This follows the same convention as other devices.
---
 hw/display/meson.build       | 11 +++++++-
 hw/display/virtio-ramfb-gl.c | 50 ++++++++++++++++++++++++++++++++++++
 hw/display/virtio-ramfb.c    | 36 +++-----------------------
 hw/display/virtio-ramfb.h    | 28 ++++++++++++++++++++
 4 files changed, 92 insertions(+), 33 deletions(-)
 create mode 100644 hw/display/virtio-ramfb-gl.c
 create mode 100644 hw/display/virtio-ramfb.h

diff --git a/hw/display/meson.build b/hw/display/meson.build
index b3d1cccadc..cadfa1479d 100644
--- a/hw/display/meson.build
+++ b/hw/display/meson.build
@@ -58,7 +58,6 @@ if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
                     if_true: [files('virtio-gpu-base.c', 'virtio-gpu.c'), pixman])
   virtio_gpu_ss.add(when: 'CONFIG_LINUX', if_true: files('virtio-gpu-udmabuf.c'))
   virtio_gpu_ss.add(when: 'CONFIG_VHOST_USER_GPU', if_true: files('vhost-user-gpu.c'))
-  virtio_gpu_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
   hw_display_modules += {'virtio-gpu': virtio_gpu_ss}
 
   virtio_gpu_gl_ss = ss.source_set()
@@ -67,6 +66,16 @@ if config_all_devices.has_key('CONFIG_VIRTIO_GPU')
   hw_display_modules += {'virtio-gpu-gl': virtio_gpu_gl_ss}
 endif
 
+if config_all_devices.has_key('CONFIG_FW_CFG_DMA')
+  virtio_ramfb_ss = ss.source_set()
+  virtio_ramfb_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
+  hw_display_modules += {'virtio-ramfb': virtio_ramfb_ss}
+  virtio_ramfb_gl_ss = ss.source_set()
+  virtio_ramfb_gl_ss.add(when: ['CONFIG_FW_CFG_DMA', virgl, opengl],
+                       if_true: files('virtio-ramfb-gl.c'))
+  hw_display_modules += {'virtio-ramfb-gl': virtio_ramfb_gl_ss}
+endif
+
 if config_all_devices.has_key('CONFIG_VIRTIO_PCI')
   virtio_gpu_pci_ss = ss.source_set()
   virtio_gpu_pci_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRTIO_PCI'],
diff --git a/hw/display/virtio-ramfb-gl.c b/hw/display/virtio-ramfb-gl.c
new file mode 100644
index 0000000000..19ddfd59de
--- /dev/null
+++ b/hw/display/virtio-ramfb-gl.c
@@ -0,0 +1,50 @@
+#include "qemu/osdep.h"
+#include "hw/pci/pci.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-gpu.h"
+#include "hw/display/vga.h"
+#include "qapi/error.h"
+#include "qemu/module.h"
+#include "virtio-ramfb.h"
+#include "qom/object.h"
+
+#define TYPE_VIRTIO_RAMFB_GL "virtio-ramfb-gl"
+
+typedef struct VirtIORAMFBGL VirtIORAMFBGL;
+DECLARE_INSTANCE_CHECKER(VirtIORAMFBGL, VIRTIO_RAMFB_GL,
+                         TYPE_VIRTIO_RAMFB_GL)
+
+struct VirtIORAMFBGL {
+    VirtIORAMFBBase parent_obj;
+
+    VirtIOGPUGL   vdev;
+};
+
+static void virtio_ramfb_gl_inst_initfn(Object *obj)
+{
+    VirtIORAMFBGL *dev = VIRTIO_RAMFB_GL(obj);
+    
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU_GL);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+}
+
+
+static VirtioPCIDeviceTypeInfo virtio_ramfb_gl_info = {
+    .generic_name  = TYPE_VIRTIO_RAMFB_GL,
+    .parent        = TYPE_VIRTIO_RAMFB_BASE,
+    .instance_size = sizeof(VirtIORAMFBGL),
+    .instance_init = virtio_ramfb_gl_inst_initfn,
+};
+module_obj(TYPE_VIRTIO_RAMFB_GL);
+
+static void virtio_ramfb_register_types(void)
+{
+    if (have_vga) {
+        virtio_pci_types_register(&virtio_ramfb_gl_info);
+    }
+}
+
+type_init(virtio_ramfb_register_types)
+
+module_dep("hw-display-virtio-ramfb");
diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
index 19a050ae5d..f7f7d23c8d 100644
--- a/hw/display/virtio-ramfb.c
+++ b/hw/display/virtio-ramfb.c
@@ -3,31 +3,10 @@
 #include "hw/pci/pci.h"
 #include "ui/console.h"
 #include "hw/qdev-properties.h"
-#include "hw/virtio/virtio-gpu-pci.h"
+#include "virtio-ramfb.h"
 #include "qapi/error.h"
-#include "hw/display/ramfb.h"
 #include "qom/object.h"
 
-/*
- * virtio-ramfb-base: This extends VirtioPCIProxy.
- */
-#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
-OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
-                    VIRTIO_RAMFB_BASE)
-
-struct VirtIORAMFBBase {
-    VirtIOPCIProxy parent_obj;
-
-    VirtIOGPUBase *vgpu;
-    RAMFBState    *ramfb;
-};
-
-struct VirtIORAMFBBaseClass {
-    VirtioPCIClass parent_class;
-
-    DeviceReset parent_reset;
-};
-
 static int virtio_ramfb_get_flags(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -197,22 +176,15 @@ struct VirtIORAMFB {
     VirtIORAMFBBase parent_obj;
 
     VirtIOGPU     vdev;
-    VirtIOGPUGL   vdevgl;
 };
 
 static void virtio_ramfb_inst_initfn(Object *obj)
 {
     VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
 
-    if (display_opengl) {
-        virtio_instance_init_common(obj, &dev->vdevgl, sizeof(dev->vdevgl),
-                                    TYPE_VIRTIO_GPU_GL);
-        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdevgl);
-    } else {
-        virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
-                                    TYPE_VIRTIO_GPU);
-        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
-    }
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
 }
 
 static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
diff --git a/hw/display/virtio-ramfb.h b/hw/display/virtio-ramfb.h
new file mode 100644
index 0000000000..73bde4ba0e
--- /dev/null
+++ b/hw/display/virtio-ramfb.h
@@ -0,0 +1,28 @@
+#ifndef VIRTIO_RAMFB_H
+#define VIRTIO_RAMFB_H
+
+#include "hw/virtio/virtio-gpu-pci.h"
+#include "hw/display/ramfb.h"
+#include "qom/object.h"
+
+/*
+ * virtio-ramfb-base: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
+OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
+                    VIRTIO_RAMFB_BASE)
+
+struct VirtIORAMFBBase {
+    VirtIOPCIProxy parent_obj;
+
+    VirtIOGPUBase *vgpu;
+    RAMFBState    *ramfb;
+};
+
+struct VirtIORAMFBBaseClass {
+    VirtioPCIClass parent_class;
+
+    DeviceReset parent_reset;
+};
+
+#endif /* VIRTIO_RAMFB_H */
-- 
2.28.0

From e73864e11d4f3224174a677a96925d253ccf892d Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Wed, 8 Sep 2021 19:58:01 -0700
Subject: [PATCH] shaders: support byte swapping of pixels

Some EGL implementations do not support GL_BGRA_EXT so we always use
a surface format of GL_RGBA and then swap the bytes with a fragment
shader.
---
 include/ui/console.h             |  1 +
 include/ui/egl-helpers.h         |  4 ++--
 include/ui/shader.h              |  2 +-
 ui/cocoa/main.m                  |  4 ++--
 ui/console-gl.c                  |  5 +++--
 ui/egl-headless.c                |  4 ++--
 ui/egl-helpers.c                 |  8 ++++----
 ui/gtk-egl.c                     |  4 ++--
 ui/shader.c                      | 26 +++++++++++++++++++++-----
 ui/shader/meson.build            |  1 +
 ui/shader/texture-blit-swap.frag |  7 +++++++
 ui/spice-display.c               | 12 ++++++------
 12 files changed, 52 insertions(+), 26 deletions(-)
 create mode 100644 ui/shader/texture-blit-swap.frag

diff --git a/include/ui/console.h b/include/ui/console.h
index d8d7649b14..bd615dd563 100644
--- a/include/ui/console.h
+++ b/include/ui/console.h
@@ -116,6 +116,7 @@ typedef struct DisplaySurface {
     GLenum glformat;
     GLenum gltype;
     GLuint texture;
+    bool   glswapped;
 #endif
 } DisplaySurface;
 
diff --git a/include/ui/egl-helpers.h b/include/ui/egl-helpers.h
index c6e95b4d5f..86a3dc6a29 100644
--- a/include/ui/egl-helpers.h
+++ b/include/ui/egl-helpers.h
@@ -36,9 +36,9 @@ void egl_fb_setup_new_tex(egl_fb *fb, int width, int height);
 void egl_fb_blit(egl_fb *dst, egl_fb *src, bool flip);
 void egl_fb_read(DisplaySurface *dst, egl_fb *src);
 
-void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip);
+void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip, bool swap);
 void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
-                       int x, int y, double scale_x, double scale_y);
+                       bool swap, int x, int y, double scale_x, double scale_y);
 
 #ifdef CONFIG_GBM
 
diff --git a/include/ui/shader.h b/include/ui/shader.h
index 4c5acb2ce8..252192793a 100644
--- a/include/ui/shader.h
+++ b/include/ui/shader.h
@@ -5,7 +5,7 @@
 
 typedef struct QemuGLShader QemuGLShader;
 
-void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip);
+void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip, bool swapped);
 
 QemuGLShader *qemu_gl_init_shader(void);
 void qemu_gl_fini_shader(QemuGLShader *gls);
diff --git a/ui/cocoa/main.m b/ui/cocoa/main.m
index 16bb4ace82..75bfedd3af 100644
--- a/ui/cocoa/main.m
+++ b/ui/cocoa/main.m
@@ -574,7 +574,7 @@ static void cocoa_gl_render_cursor()
     glBindTexture(GL_TEXTURE_2D, cursor_texture);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(gls, false);
+    qemu_gl_run_texture_blit(gls, false, false);
     glDisable(GL_BLEND);
 }
 
@@ -671,7 +671,7 @@ static void cocoa_gl_scanout_flush(DisplayChangeListener *dcl,
         glBindFramebuffer(GL_FRAMEBUFFER_EXT, 0);
         glViewport(0, 0, size.width, size.height);
         glBindTexture(GL_TEXTURE_2D, texture);
-        qemu_gl_run_texture_blit(gls, y0_top);
+        qemu_gl_run_texture_blit(gls, y0_top, false);
 
         cocoa_gl_render_cursor();
 
diff --git a/ui/console-gl.c b/ui/console-gl.c
index 7c9894a51d..7d702b7a21 100644
--- a/ui/console-gl.c
+++ b/ui/console-gl.c
@@ -52,8 +52,9 @@ void surface_gl_create_texture(QemuGLShader *gls,
     switch (surface->format) {
     case PIXMAN_BE_b8g8r8x8:
     case PIXMAN_BE_b8g8r8a8:
-        surface->glformat = GL_BGRA_EXT;
+        surface->glformat = GL_RGBA;
         surface->gltype = GL_UNSIGNED_BYTE;
+        surface->glswapped = true;
         break;
     case PIXMAN_BE_x8r8g8b8:
     case PIXMAN_BE_a8r8g8b8:
@@ -121,7 +122,7 @@ void surface_gl_render_texture(QemuGLShader *gls,
     glClearColor(0.1f, 0.1f, 0.1f, 0.0f);
     glClear(GL_COLOR_BUFFER_BIT);
 
-    qemu_gl_run_texture_blit(gls, false);
+    qemu_gl_run_texture_blit(gls, false, false);
 }
 
 void surface_gl_destroy_texture(QemuGLShader *gls,
diff --git a/ui/egl-headless.c b/ui/egl-headless.c
index 460a4f9e8f..03afc57bdf 100644
--- a/ui/egl-headless.c
+++ b/ui/egl-headless.c
@@ -165,9 +165,9 @@ static void egl_scanout_flush(DisplayChangeListener *dcl,
     if (edpy->cursor_fb.texture) {
         /* have cursor -> render using textures */
         egl_texture_blit(edpy->gls, &edpy->blit_fb, &edpy->guest_fb,
-                         !edpy->y_0_top);
+                         !edpy->y_0_top, false);
         egl_texture_blend(edpy->gls, &edpy->blit_fb, &edpy->cursor_fb,
-                          !edpy->y_0_top, edpy->pos_x, edpy->pos_y,
+                          false, !edpy->y_0_top, edpy->pos_x, edpy->pos_y,
                           1.0, 1.0);
     } else {
         /* no cursor -> use simple framebuffer blit */
diff --git a/ui/egl-helpers.c b/ui/egl-helpers.c
index c38667661b..8620a2272d 100644
--- a/ui/egl-helpers.c
+++ b/ui/egl-helpers.c
@@ -122,17 +122,17 @@ void egl_fb_read(DisplaySurface *dst, egl_fb *src)
                  GL_BGRA, GL_UNSIGNED_BYTE, surface_data(dst));
 }
 
-void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip)
+void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip, bool swap)
 {
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
     glViewport(0, 0, dst->width, dst->height);
     glEnable(GL_TEXTURE_2D);
     glBindTexture(src->texture_target, src->texture);
-    qemu_gl_run_texture_blit(gls, flip);
+    qemu_gl_run_texture_blit(gls, flip, swap);
 }
 
 void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
-                       int x, int y, double scale_x, double scale_y)
+                       bool swap, int x, int y, double scale_x, double scale_y)
 {
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
     int w = scale_x * src->width;
@@ -146,7 +146,7 @@ void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
     glBindTexture(src->texture_target, src->texture);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(gls, flip);
+    qemu_gl_run_texture_blit(gls, flip, swap);
     glDisable(GL_BLEND);
 }
 
diff --git a/ui/gtk-egl.c b/ui/gtk-egl.c
index 43be2a3610..95b2c99ec5 100644
--- a/ui/gtk-egl.c
+++ b/ui/gtk-egl.c
@@ -299,9 +299,9 @@ void gd_egl_scanout_flush(DisplayChangeListener *dcl,
     egl_fb_setup_default(&vc->gfx.win_fb, ww, wh);
     if (vc->gfx.cursor_fb.texture) {
         egl_texture_blit(vc->gfx.gls, &vc->gfx.win_fb, &vc->gfx.guest_fb,
-                         vc->gfx.y0_top);
+                         vc->gfx.y0_top, false);
         egl_texture_blend(vc->gfx.gls, &vc->gfx.win_fb, &vc->gfx.cursor_fb,
-                          vc->gfx.y0_top,
+                          vc->gfx.y0_top, false,
                           vc->gfx.cursor_x, vc->gfx.cursor_y,
                           vc->gfx.scale_x, vc->gfx.scale_y);
     } else {
diff --git a/ui/shader.c b/ui/shader.c
index ae1784e7c4..26c5618298 100644
--- a/ui/shader.c
+++ b/ui/shader.c
@@ -30,10 +30,13 @@
 #include "ui/shader/texture-blit-vert.h"
 #include "ui/shader/texture-blit-flip-vert.h"
 #include "ui/shader/texture-blit-frag.h"
+#include "ui/shader/texture-blit-swap-frag.h"
 
 struct QemuGLShader {
     GLint texture_blit_prog;
     GLint texture_blit_flip_prog;
+    GLint texture_blit_swap_prog;
+    GLint texture_blit_flip_swap_prog;
     GLint texture_blit_vao;
 };
 
@@ -69,11 +72,17 @@ static GLuint qemu_gl_init_texture_blit(GLint texture_blit_prog)
     return vao;
 }
 
-void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip)
+void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip, bool swapped)
 {
-    glUseProgram(flip
-                 ? gls->texture_blit_flip_prog
-                 : gls->texture_blit_prog);
+    if (flip && swapped) {
+        glUseProgram(gls->texture_blit_flip_swap_prog);
+    } else if (flip && !swapped) {
+        glUseProgram(gls->texture_blit_flip_prog);
+    } else if (!flip && swapped) {
+        glUseProgram(gls->texture_blit_swap_prog);
+    } else { // !flip && !swapped
+        glUseProgram(gls->texture_blit_prog);
+    }
     glBindVertexArray(gls->texture_blit_vao);
     glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 }
@@ -163,7 +172,14 @@ QemuGLShader *qemu_gl_init_shader(void)
     strcpy(vert_src_body, texture_blit_flip_vert_src);
     gls->texture_blit_flip_prog = qemu_gl_create_compile_link_program
         (vert_src, frag_src);
-    if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog) {
+    strcpy(frag_src_body, texture_blit_swap_frag_src);
+    gls->texture_blit_flip_swap_prog = qemu_gl_create_compile_link_program
+        (vert_src, frag_src);
+    strcpy(vert_src_body, texture_blit_vert_src);
+    gls->texture_blit_swap_prog = qemu_gl_create_compile_link_program
+        (vert_src, frag_src);
+    if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog ||
+        !gls->texture_blit_swap_prog || !gls->texture_blit_flip_swap_prog) {
         exit(1);
     }
 
diff --git a/ui/shader/meson.build b/ui/shader/meson.build
index 592bf596b9..90b5fa04e6 100644
--- a/ui/shader/meson.build
+++ b/ui/shader/meson.build
@@ -1,5 +1,6 @@
 shaders = [
   ['texture-blit', 'frag'],
+  ['texture-blit-swap', 'frag'],
   ['texture-blit', 'vert'],
   ['texture-blit-flip', 'vert'],
 ]
diff --git a/ui/shader/texture-blit-swap.frag b/ui/shader/texture-blit-swap.frag
new file mode 100644
index 0000000000..8c97bcbac5
--- /dev/null
+++ b/ui/shader/texture-blit-swap.frag
@@ -0,0 +1,7 @@
+uniform sampler2D image;
+in  mediump vec2 ex_tex_coord;
+out mediump vec4 out_frag_color;
+
+void main(void) {
+     out_frag_color = texture(image, ex_tex_coord).zyxw;
+}
diff --git a/ui/spice-display.c b/ui/spice-display.c
index 0bb210a2c2..a6afc87be8 100644
--- a/ui/spice-display.c
+++ b/ui/spice-display.c
@@ -929,7 +929,7 @@ static int spice_iosurface_create_fd(SimpleSpiceDisplay *ssd, int *fourcc)
     return fds[0];
 }
 
-static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip)
+static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip, bool swap)
 {
     egl_fb tmp_fb = { .texture = src_texture, .texture_target = GL_TEXTURE_2D };
     if (!ssd->iosurface) {
@@ -940,7 +940,7 @@ static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bo
     eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
     glBindTexture(ssd->iosurface_fb.texture_target, ssd->iosurface_fb.texture);
     eglBindTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
-    egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip);
+    egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip, swap);
 #endif
 }
 
@@ -1041,7 +1041,7 @@ static void spice_gl_update(DisplayChangeListener *dcl,
     surface_gl_update_texture(ssd->gls, ssd->ds, x, y, w, h);
 #if defined(CONFIG_IOSURFACE)
     if (!qemu_console_is_gl_blocked(ssd->dcl.con)) {
-        spice_iosurface_blit(ssd, ssd->ds->texture, true);
+        spice_iosurface_blit(ssd, ssd->ds->texture, true, ssd->ds->glswapped);
     }
 #endif
     ssd->gl_updates++;
@@ -1315,15 +1315,15 @@ static void qemu_spice_gl_update(DisplayChangeListener *dcl,
         y = ssd->ptr_y;
         qemu_mutex_unlock(&ssd->lock);
         egl_texture_blit(ssd->gls, &ssd->blit_fb, &ssd->guest_fb,
-                         !y_0_top);
+                         !y_0_top, false);
         egl_texture_blend(ssd->gls, &ssd->blit_fb, &ssd->cursor_fb,
-                          !y_0_top, x, y, 1.0, 1.0);
+                          !y_0_top, false, x, y, 1.0, 1.0);
         glFlush();
     }
 #elif defined(CONFIG_ANGLE) && defined(CONFIG_IOSURFACE)
     GLuint tex_id = ssd->backing_borrow(ssd->backing_id, &y_0_top,
                                         NULL, NULL);
-    spice_iosurface_blit(ssd, tex_id, !y_0_top);
+    spice_iosurface_blit(ssd, tex_id, !y_0_top, false);
     spice_iosurface_flush(ssd);
     //TODO: cursor stuff
 #endif
-- 
2.28.0

From cec8d31d7a48c216e83e3505c41d9ac1aa493159 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Sun, 26 Sep 2021 15:36:00 -0700
Subject: [PATCH] resolv: fix IPv6 resolution on Darwin

res_sockaddr_union() has a field for IPv4 and a field for IPv6. When we
used `&servers[i].sin.sin_addr`, it does not return the right address
for IPv6.
---
 src/slirp.c | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/subprojects/libslirp/src/slirp.c b/subprojects/libslirp/src/slirp.c
index a669b45..0583e5b 100644
--- a/subprojects/libslirp/src/slirp.c
+++ b/subprojects/libslirp/src/slirp.c
@@ -143,6 +143,10 @@ static int get_dns_addr_libresolv(int af, void *pdns_addr, void *cached_addr,
     union res_sockaddr_union servers[NI_MAXSERV];
     int count;
     int found;
+    void *addr;
+
+    // we only support IPv4 and IPv4, we assume it's one or the other
+    assert(af == AF_INET || af == AF_INET6);
 
     if (res_ninit(&state) != 0) {
         return -1;
@@ -155,11 +159,16 @@ static int get_dns_addr_libresolv(int af, void *pdns_addr, void *cached_addr,
         if (af == servers[i].sin.sin_family) {
             found++;
         }
+        if (af == AF_INET) {
+            addr = &servers[i].sin.sin_addr;
+        } else { // af == AF_INET6
+            addr = &servers[i].sin6.sin6_addr;
+        }
 
         // we use the first found entry
         if (found == 1) {
-            memcpy(pdns_addr, &servers[i].sin.sin_addr, addrlen);
-            memcpy(cached_addr, &servers[i].sin.sin_addr, addrlen);
+            memcpy(pdns_addr, addr, addrlen);
+            memcpy(cached_addr, addr, addrlen);
             if (scope_id) {
                 *scope_id = 0;
             }
@@ -171,10 +180,7 @@ static int get_dns_addr_libresolv(int af, void *pdns_addr, void *cached_addr,
             break;
         } else if (slirp_debug & DBG_MISC) {
             char s[INET6_ADDRSTRLEN];
-            const char *res = inet_ntop(servers[i].sin.sin_family,
-                                        &servers[i].sin.sin_addr,
-                                        s,
-                                        sizeof(s));
+            const char *res = inet_ntop(af, addr, s, sizeof(s));
             if (!res) {
                 res = "  (string conversion error)";
             }
-- 
2.28.0

From patchwork Tue Oct 26 07:12:41 2021
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-Patchwork-Submitter: Alexander Graf <agraf@csgraf.de>
X-Patchwork-Id: 12584125
Return-Path: 
 <SRS0=K6hM=PO=nongnu.org=qemu-devel-bounces+qemu-devel=archiver.kernel.org@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 49FD2C433EF
	for <qemu-devel@archiver.kernel.org>; Tue, 26 Oct 2021 08:08:16 +0000 (UTC)
Received: from lists.gnu.org (lists.gnu.org [209.51.188.17])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by mail.kernel.org (Postfix) with ESMTPS id BA335610A0
	for <qemu-devel@archiver.kernel.org>; Tue, 26 Oct 2021 08:08:15 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.4.1 mail.kernel.org BA335610A0
Authentication-Results: mail.kernel.org;
 dmarc=none (p=none dis=none) header.from=csgraf.de
Authentication-Results: mail.kernel.org; spf=pass smtp.mailfrom=nongnu.org
Received: from localhost ([::1]:36942 helo=lists1p.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.90_1)
	(envelope-from
 <qemu-devel-bounces+qemu-devel=archiver.kernel.org@nongnu.org>)
	id 1mfHVG-0004hG-Ru
	for qemu-devel@archiver.kernel.org; Tue, 26 Oct 2021 04:08:14 -0400
Received: from eggs.gnu.org ([2001:470:142:3::10]:57414)
 by lists.gnu.org with esmtps (TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256)
 (Exim 4.90_1) (envelope-from <agraf@csgraf.de>) id 1mfGdf-00045B-Qy
 for qemu-devel@nongnu.org; Tue, 26 Oct 2021 03:12:51 -0400
Received: from mail.csgraf.de ([85.25.223.15]:49104
 helo=zulu616.server4you.de)
 by eggs.gnu.org with esmtp (Exim 4.90_1)
 (envelope-from <agraf@csgraf.de>) id 1mfGdZ-0008O2-40
 for qemu-devel@nongnu.org; Tue, 26 Oct 2021 03:12:49 -0400
Received: from localhost.localdomain
 (dynamic-077-007-071-240.77.7.pool.telefonica.de [77.7.71.240])
 by csgraf.de (Postfix) with ESMTPSA id A8F486080126;
 Tue, 26 Oct 2021 09:12:42 +0200 (CEST)
From: Alexander Graf <agraf@csgraf.de>
To: Cameron Esfahani <dirty@apple.com>
Subject: [PATCH v2] hvf: arm: Ignore cache operations on MMIO
Date: Tue, 26 Oct 2021 09:12:41 +0200
Message-Id: <20211026071241.74889-1-agraf@csgraf.de>
X-Mailer: git-send-email 2.30.1 (Apple Git-130)
MIME-Version: 1.0
Received-SPF: pass client-ip=85.25.223.15; envelope-from=agraf@csgraf.de;
 helo=zulu616.server4you.de
X-Spam_score_int: -18
X-Spam_score: -1.9
X-Spam_bar: -
X-Spam_report: (-1.9 / 5.0 requ) BAYES_00=-1.9, SPF_HELO_NONE=0.001,
 SPF_PASS=-0.001 autolearn=ham autolearn_force=no
X-Spam_action: no action
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.23
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <https://lists.nongnu.org/archive/html/qemu-devel>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: kettenis@openbsd.org, Richard Henderson <richard.henderson@linaro.org>,
	=?utf-8?q?Philippe_Mathieu-Daud=C3=A9?= <f4bug@amsat.org>,
 qemu-devel@nongnu.org, Roman Bolshakov <r.bolshakov@yadro.com>,
 Paolo Bonzini <pbonzini@redhat.com>
Errors-To: qemu-devel-bounces+qemu-devel=archiver.kernel.org@nongnu.org
Sender: "Qemu-devel"
 <qemu-devel-bounces+qemu-devel=archiver.kernel.org@nongnu.org>

Apple's Hypervisor.Framework forwards cache operations as MMIO traps
into user space. For MMIO however, these have no meaning: There is no
cache attached to them.

So let's just treat cache data exits as nops.

This fixes OpenBSD booting as guest.

Signed-off-by: Alexander Graf <agraf@csgraf.de>
Reported-by: AJ Barris <AwlsomeAlex@github.com>
Reference: https://github.com/utmapp/UTM/issues/3197
Reviewed-by: Philippe Mathieu-Daud <f4bug@amsat.org>
Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
---
 target/arm/hvf/hvf.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index bff3e0cde7..0dc96560d3 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -1150,12 +1150,19 @@ int hvf_vcpu_exec(CPUState *cpu)
         uint32_t sas = (syndrome >> 22) & 3;
         uint32_t len = 1 << sas;
         uint32_t srt = (syndrome >> 16) & 0x1f;
+        uint32_t cm = (syndrome >> 8) & 0x1;
         uint64_t val = 0;
 
         trace_hvf_data_abort(env->pc, hvf_exit->exception.virtual_address,
                              hvf_exit->exception.physical_address, isv,
                              iswrite, s1ptw, len, srt);
 
+        if (cm) {
+            /* We don't cache MMIO regions */
+            advance_pc = true;
+            break;
+        }
+
         assert(isv);
 
         if (iswrite) {
